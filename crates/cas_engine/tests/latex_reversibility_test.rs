//! Integration tests for LaTeX reversibility
//!
//! This module tests that LaTeX generated by the simplification engine
//! can be parsed back into expressions with identical LaTeX output.

use cas_ast::Context;
use cas_engine::Simplifier;
use cas_formatter::LaTeXExpr;
use cas_parser::parse;
use cas_parser::parse_latex;

/// Test that LaTeX output is reversible: parse → expr → latex → parse → latex should be stable
fn assert_latex_reversible(latex: &str) {
    let mut ctx = Context::new();
    let result = parse_latex(&mut ctx, latex);
    match result {
        Ok(expr_id) => {
            let regenerated = LaTeXExpr {
                context: &ctx,
                id: expr_id,
            }
            .to_latex();
            assert_eq!(
                latex, regenerated,
                "\n❌ REVERSIBILITY FAILURE:\n   Input:       '{}'\n   Regenerated: '{}'",
                latex, regenerated
            );
        }
        Err(e) => {
            panic!(
                "\n❌ PARSE FAILURE:\n   LaTeX: '{}'\n   Error: {}",
                latex, e
            );
        }
    }
}

/// Test a set of LaTeX strings from a specific simplification
fn test_latex_from_simplification(input: &str) {
    let mut simplifier = Simplifier::new();
    let expr_id = parse(input, &mut simplifier.context).expect("Failed to parse input");
    let (result, steps) = simplifier.simplify(expr_id);

    println!("Testing LaTeX for: {}", input);
    println!("Steps: {}", steps.len());

    // Test LaTeX for each step's before/after
    for (i, step) in steps.iter().enumerate() {
        // Test local before
        let before_latex = LaTeXExpr {
            context: &simplifier.context,
            id: step.before,
        }
        .to_latex();
        println!("  Step {} before: {}", i + 1, before_latex);

        // Try to parse it back
        let mut test_ctx = Context::new();
        if let Err(e) = parse_latex(&mut test_ctx, &before_latex) {
            println!("    ❌ Failed to parse: {}", e);
        } else {
            println!("    ✓ Parsed OK");
        }

        // Test local after
        let after_latex = LaTeXExpr {
            context: &simplifier.context,
            id: step.after,
        }
        .to_latex();
        println!("  Step {} after: {}", i + 1, after_latex);

        let mut test_ctx = Context::new();
        if let Err(e) = parse_latex(&mut test_ctx, &after_latex) {
            println!("    ❌ Failed to parse: {}", e);
        } else {
            println!("    ✓ Parsed OK");
        }
    }

    // Test final result
    let result_latex = LaTeXExpr {
        context: &simplifier.context,
        id: result,
    }
    .to_latex();
    println!("  Result: {}", result_latex);
}

#[test]
fn test_timeline_latex_sqrt_expression() {
    test_latex_from_simplification("sqrt(x * (x * x^(1/4))^(1/3)) - x^(1/2 + 1/6 + 1/24)");
}

#[test]
fn test_simple_power_latex() {
    // Test basic reversibility
    assert_latex_reversible("{x}^{2}");
    assert_latex_reversible("\\frac{1}{2}");
    assert_latex_reversible("x + y");
    assert_latex_reversible("x - y");
}

#[test]
fn test_power_with_fraction_exponent() {
    // V2.14.40: Fractional powers now render as sqrt by default
    // Input: {x}^{\frac{17}{24}} -> x^(17/24) -> sqrt[24]{x^17}
    assert_latex_reversible("\\sqrt[24]{{x}^{17}}");
}

#[test]
fn test_subtraction_same_terms() {
    // V2.14.40: Fractional powers now render as sqrt by default
    // This was the problematic case in timeline step 5
    assert_latex_reversible("\\sqrt[24]{{x}^{17}} - \\sqrt[24]{{x}^{17}}");
}

#[test]
fn test_sqrt_with_power_inside() {
    // V2.14.40: sqrt { x^(17/12) } -> sqrt { sqrt[12]{x^17} }
    assert_latex_reversible("\\sqrt{\\sqrt[12]{{x}^{17}}}");
}

#[test]
fn test_complex_expression() {
    // V2.14.40: Fractional powers now render as sqrt by default
    // Full expression from timeline
    assert_latex_reversible("\\sqrt{\\sqrt[12]{{x}^{17}}} - \\sqrt[24]{{x}^{17}}");
}
